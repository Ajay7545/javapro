package ProjectJava;

import java.awt.Color;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JLabel;
import javax.swing.JScrollBar;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;


public class javaz extends JDialog implements ActionListener
{
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private JButton hp;
	private JButton cancel;
	public javaz() 
	{
		ImageIcon iio= new ImageIcon(getClass().getResource("img/pp.jpg"));
		
		getContentPane().setBackground(Color.PINK);
		getContentPane().setForeground(Color.WHITE);
	
		
		
		getContentPane().setLayout(null);
		
		JLabel lblJavaProgramming = new JLabel("Java Programming");
		lblJavaProgramming.setForeground(Color.LIGHT_GRAY);
		lblJavaProgramming.setFont(new Font("Times New Roman", Font.BOLD | Font.ITALIC, 33));
		lblJavaProgramming.setBounds(82, 11, 291, 43);
		getContentPane().add(lblJavaProgramming);
		
		hp = new JButton("Back to HomePage");
		hp.setToolTipText("Click for Home Page");
		hp.setBackground(new Color(47, 79, 79));
		hp.setForeground(new Color(192, 192, 192));
		hp.setBounds(127, 380, 148, 23);
		getContentPane().add(hp);
		
		cancel = new JButton("Exit");
		cancel.setToolTipText("Click to Cancel");
		cancel.setBackground(new Color(255, 0, 0));
		cancel.setForeground(new Color(230, 230, 250));
		cancel.setBounds(323, 380, 89, 23);
		getContentPane().add(cancel);
								
								JTextArea txtrObjectorientedProgrammingConcepts = new JTextArea();
								txtrObjectorientedProgrammingConcepts.setText("Object-oriented programming concepts and principles\r\nThe Java language is (mostly) object oriented. This section is an introduction to OOP language concepts, using structured programming as a point of contrast.\r\nWhat is an object?\r\nObject-oriented languages follow a different programming pattern from structured programming languages like C and COBOL. The structured-programming paradigm is highly data oriented: You have data structures, and then program instructions act on that data. Object-oriented languages such as the Java language combine data and program instructions into objects.\r\nAn object is a self-contained entity that contains attributes and behavior, and nothing more. Instead of having a data structure with fields (attributes) and passing that structure around to all of the program logic that acts on it (behavior), in an object-oriented language, data and program logic are combined. This combination can occur at vastly different levels of granularity, from fine-grained objects such as aNumber, to coarse-grained objects, such as a FundsTransfer service in a large banking application.\r\nParent and child objects\r\nA parent object is one that serves as the structural basis for deriving more-complex child objects. A child object looks like its parent but is more specialized. With the object-oriented paradigm, you can reuse the common attributes and behavior of the parent object, adding to its child objects attributes and behavior that differ.\r\nObject communication and coordination\r\nObjects talk to other objects by sending messages (method calls, in Java parlance). Furthermore, in an object-oriented application, program code coordinates the activities among objects to perform tasks within the context of the specific application domain.\r\nObject summary\r\nA well-written object:\r\n\u2022\tHas well-defined boundaries\r\n\u2022\tPerforms a finite set of activities\r\n\u2022\tKnows only about its data and any other objects that it needs to accomplish its activities\r\nIn essence, an object is a discrete entity that has only the necessary dependencies on other objects to perform its tasks.\r\nIt's time to see what a Java object looks like.\r\nExample: A person object\r\nThis first example is based on a common application-development scenario: an individual being represented by a Person object.\r\nYou know from the definition of an object that an object has two primary elements: attributes and behavior. Here's how these elements apply to the Person object.\r\nAs a rule of thumb, think of the attributes of an object as nouns and behavior as verbs.\r\nAttributes (nouns)\r\nWhat attributes can a person have? Some common ones include:\r\n\u2022\tName\r\n\u2022\tAge\r\n\u2022\tHeight\r\n\u2022\tWeight\r\n\u2022\tEye color\r\n\u2022\tGender\r\nYou can probably think of more (and you can always add more attributes later), but this list is a good start.\r\nBehavior (verbs)\r\nAn actual person can do all sorts of things, but object behaviors usually relate to application context of some kind. In a business-application context, for instance, you might want to ask your Person object, \"What is your body mass index (BMI)?\" In response, Person would use the values of its height and weight attributes to calculate the BMI.\r\nMore-complex logic can be hidden inside of the Person object, but for now, suppose that Person has the following behavior:\r\n\u2022\tCalculate BMI\r\n\u2022\tPrint all attributes\r\nState and string\r\nState is an important concept in OOP. An object's state is represented at any moment in time by the values of its attributes.\r\nIn the case of Person, its state is defined by attributes such as name, age, height, and weight. If you wanted to present a list of several of those attributes, you might do so by using a String class, which you'll learn more about later.\r\nUsing the concepts of state and string together, you can say to Person, \"Tell me all about you by giving me a listing (or String) of your attributes.\"\r\nPrinciples of OOP\r\nIf you come from a structured-programming background, the OOP value proposition might not be clear yet. After all, the attributes of a person and any logic to retrieve (and convert) those values can be written in C or COBOL. The benefits of the OOP paradigm become clearer if you understand its defining principles: encapsulation, inheritance, and polymorphism.\r\nEncapsulation\r\nRecall that an object is above all discrete, or self-contained. This characteristic is the principle of encapsulation at work. Hiding is another term that's sometimes used to express the self-contained, protected nature of objects.\r\nRegardless of terminology, what's important is that the object maintains a boundary between its state and behavior and the outside world. Like objects in the real world, objects used in computer programming have various types of relationships with different categories of objects in the applications that use them.\r\nOn the Java platform, you can use access modifiers (which you'll learn about later) to vary the nature of object relationships from public to private. Public access is wide open, whereas private access means the object's attributes are accessible only within the object itself.\r\nThe public/private boundary enforces the object-oriented principle of encapsulation. On the Java platform, you can vary the strength of that boundary on an object-by-object basis. Encapsulation is a powerful feature of the Java language.\r\nInheritance\r\nIn structured programming, it's common to copy a structure, give it a new name, and add or modify the attributes that make the new entity (such as an Account record) different from its original source. Over time, this approach generates a great deal of duplicated code, which can create maintenance issues.\r\nOOP introduces the concept of inheritance, whereby specialized classes \u2014 without additional code \u2014 can \"copy\" the attributes and behavior of the source classes that they specialize. If some of those attributes or behaviors need to change, you override them. The only source code you change is the code needed for creating specialized classes. The source object is called the parent, and the new specialization is called the child\u2014 terms that you've already been introduced to.\r\nSuppose that you're writing a human-resources application and want to use the Person class as the basis (also called the super class) for a new class called Employee. Being the child of Person, Employee would have all of the attributes of a Person class, along with additional ones, such as:\r\n\u2022\tTaxpayer identification number\r\n\u2022\tEmployee number\r\n\u2022\tSalary\r\nInheritance makes it easy to create the new Employee class without needing to copy all of the Personcode manually.\r\nPolymorphism\r\nPolymorphism is a harder concept to grasp than encapsulation and inheritance. In essence, polymorphism means that objects that belong to the same branch of a hierarchy, when sent the same message (that is, when told to do the same thing), can manifest that behavior differently.\r\nTo understand how polymorphism applies to a business-application context, return to the Personexample. Remember telling Person to format its attributes into a String? Polymorphism makes it possible for Person to represent its attributes in various ways depending on the type of Person it is.\r\nPolymorphism, one of the more complex concepts you'll encounter in OOP on the Java platform, is beyond the scope of this introductory tutorial. You'll explore encapsulation and inheritance in more depth in subsequent sections.\r\nNot a purely object-oriented language\r\nTwo qualities differentiate the Java language from purely object-oriented languages such as Smalltalk. First, the Java language is a mixture of objects and primitive types. Second, with Java, you can write code that exposes the inner workings of one object to any other object that uses it.\r\nThe Java language does give you the tools necessary to follow sound OOP principles and produce sound object-oriented code. Because Java is not purely object oriented, you must exercise discipline in how you write code \u2014 the language doesn't force you to do the right thing, so you must do it yourself. You'll get tips in the \"Writing good Java code\" section.\r\nGetting started with the Java language\r\nIt would be impossible to introduce the entire Java language syntax in a single tutorial. The remainder of Part 1 focuses on the basics of the language, leaving you with enough knowledge and practice to write simple programs. OOP is all about objects, so this section starts with two topics specifically related to how the Java language handles them: reserved words and the structure of a Java object.\r\nReserved words\r\nLike any programming language, the Java language designates certain words that the compiler recognizes as special. For that reason, you're not allowed to use them for naming your Java constructs. The list of reserved words (also called keywords) is surprisingly short:\r\nabstract\r\nassert\r\nboolean\r\nbreak\r\nbyte\r\ncase\r\ncatch\r\nchar\r\nclass\r\nconst\r\ncontinue\r\ndefault\r\ndo\r\ndouble\r\nelse\r\nenum\r\nextends\r\nfinal\r\nfinally\r\nfloat\r\nfor\r\ngoto\r\nif\r\nimplements\r\nimport\r\ninstanceof\r\nint\r\ninterface\r\nlong\r\nnative\r\nnew\r\npackage\r\nprivate\r\nprotected\r\npublic\r\nreturn\r\nshort\r\nstatic\r\nstrictfp\r\nsuper\r\nswitch\r\nsynchronized\r\nthis\r\nthrow\r\nthrows\r\ntransient\r\ntry\r\nvoid\r\nvolatile\r\nwhile\r\nYou also may not use true, false, and null (technically, literals rather than keywords) to name Java constructs\r\nOne advantage of programming with an IDE is that it can use syntax coloring for reserved words.\r\nStructure of a Java class\r\nA class is a blueprint for a discrete entity (object) that contains attributes and behavior. The class defines the object's basic structure; at runtime, your application creates an instance of the object. An object has a well-defined boundary and a state, and it can do things when correctly asked. Every object-oriented language has rules about how to define a class.\r\nIn the Java language, classes are defined as shown in Listing 1:\r\nListing 1. Class definition\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n15\r\n16\tpackage packageName;\r\nimport ClassNameToImport; \r\naccessSpecifier class ClassName {\r\n  accessSpecifier dataType variableName [= initialValue];\r\n  accessSpecifier ClassName([argumentList]) {\r\n    constructorStatement(s)\r\n  }\r\n  accessSpecifier returnType methodName ([argumentList]) {\r\n    methodStatement(s)\r\n  }\r\n  // This is a comment\r\n  /* This is a comment too */\r\n  /* This is a\r\n     multiline\r\n     comment */\r\n}\r\nNote\r\nIn Listing 1 and some other code examples in this section, square brackets indicate that the constructs within them are not required. The brackets (unlike { and }) are not part of the Java syntax.\r\nListing 1 contains various types of constructs, including package in line 1, import in line 2, and class in line 3. Those three constructs are in the list of reserved words, so they must be exactly what they are in Listing 1. The names that I've given the other constructs in Listing 1 describe the concepts that they represent.\r\nNotice that lines 11 through 15 in Listing 1 are comment lines. In most programming languages, programmers can add comments to help document the code. Java syntax allows for both single-line and multiline comments:\r\n// This is a comment\r\n/* This is a comment too */\r\n/* This is a\r\nmultiline\r\ncomment */\r\nA single-line comment must be contained on one line, although you can use adjacent single-line comments to form a block. A multiline comment begins with /*, must be terminated with */, and can span any number of lines.\r\nNext, I'll walk you through the constructs in Listing 1 in detail, starting with package.\r\nPackaging classes\r\nWith the Java language, you can choose the names for your classes, such as Account, Person, or LizardMan. At times, you might end up using the same name to express two slightly different concepts. This situation, called a name collision, happens frequently. The Java language uses packages to resolve these conflicts.\r\nA Java package is a mechanism for providing a namespace\u2014 an area inside of which names are unique, but outside of which they might not be. To identify a construct uniquely, you must fully qualify it by including its namespace.\r\nPackages also give you a nice way to build more-complex applications with discrete units of functionality.\r\nTo define a package, use the package keyword followed by a legal package name, ending with a semicolon. Often package names follow this de facto standard scheme:\r\npackage  orgType.orgName.appName.compName;\r\nThis package definition breaks down as:\r\n\u2022\torgType is the organization type, such as com, org, or net.\r\n\u2022\torgName is the name of the organization's domain, such as makotojava, oracle, or ibm.\r\n\u2022\tappName is the name of the application, abbreviated.\r\n\u2022\tcompName is the name of the component.\r\nYou'll use this convention throughout this tutorial, and I recommend that you keep using it to define all of your Java classes in packages. (The Java language doesn't force you to follow this package convention. You don't need to specify a package at all, in which case all of your classes must have unique names and are in the default package.)\r\nImport statements\r\nEclipse simplifies imports\r\nWhen you write code in the Eclipse editor, you can type the name of a class you want to use, followed by Ctrl+Shift+O. Eclipse figures out which imports you need and adds them automatically. If Eclipse finds two classes with the same name, Eclipse asks you which class you want to add imports for.\r\nUp next in the class definition (referring back to Listing 1) is the import statement. An import statement tells the Java compiler where to find classes that you reference inside of your code. Any nontrivial class uses other classes for some functionality, and the import statement is how you tell the Java compiler about them.\r\nAn import statement usually looks like this:\r\nimport ClassNameToImport;\r\nYou specify the import keyword, followed by the class that you want to import, followed by a semicolon. The class name should be fully qualified, meaning that it should include its package.\r\nTo import all classes within a package, you can put .* after the package name. For example, this statement imports every class in the com.makotojava package:\r\nimport com.makotojava.*;\r\nImporting an entire package can make your code less readable, however, so I recommend that you import only the classes that you need, using their fully qualified names.\r\nClass declaration\r\nTo define an object in the Java language, you must declare a class. Think of a class as a template for an object, like a cookie cutter.\r\nListing 1 includes this class declaration:\r\naccessSpecifier class ClassName {\r\n  accessSpecifier dataType variableName [= initialValue];\r\n    accessSpecifier ClassName([argumentList]) {\r\n    constructorStatement(s)\r\n  }\r\n  accessSpecifier returnType methodName([argumentList]) {\r\n    methodStatement(s)\r\n  }\r\n}\r\nA class's accessSpecifier can have several values, but usually it's public. You'll look at other values of accessSpecifier soon.\r\nYou can name classes pretty much however you want, but the convention is to use camel case: Start with an uppercase letter, put the first letter of each concatenated word in uppercase, and make all the other letters lowercase. Class names should contain only letters and numbers. Sticking to these guidelines ensures that your code is more accessible to other developers who are following the same conventions.\r\nVariables and methods\r\nClasses can have two types of members\u2014variables and methods.\r\nVariables\r\nThe values of a class's variables distinguish each instance of that class and define its state. These values are often referred to as instance variables. A variable has:\r\n\u2022\tAn accessSpecifier\r\n\u2022\tA dataType\r\n\u2022\tA variableName\r\n\u2022\tOptionally, an initialValue\r\nThe possible accessSpecifier values are:\r\nPublic variables\r\nIt's never a good idea to use public variables, but in extremely rare cases it can be necessary, so the option exists. The Java platform doesn't constrain your use cases, so it's up to you to be disciplined about using good coding conventions, even if tempted to do otherwise.\r\n\u2022\tpublic: Any object in any package can see the variable. (Don't ever use this value; see the Public variables sidebar.)\r\n\u2022\tprotected: Any object defined in the same package, or a subclass (defined in any package), can see the variable.\r\n\u2022\tNo specifier (also called friendly or package private access): Only objects whose classes are defined in the same package can see the variable.\r\n\u2022\tprivate: Only the class containing the variable can see it.\r\nA variable's dataType depends on what the variable is \u2014 it might be a primitive type or another class type (more about this later).\r\nThe variableName is up to you, but by convention, variable names use the camel case convention, except that they begin with a lowercase letter. (This style is sometimes called lower camel case.)\r\nDon't worry about the initialValue for now; just know that you can initialize an instance variable when you declare it. (Otherwise, the compiler generates a default for you that is set when the class is instantiated.)\r\nExample: Class definition for Person\r\nHere's an example that summarizes what you've learned so far. Listing 2 is a class definition for Person.\r\nListing 2. Basic class definition for Person\r\npackage com.makotojava.intro;\r\n \r\npublic class Person {\r\n   private String name;\r\n   private int age;\r\n   private int height;\r\n   private int weight;\r\n   private String eyeColor;\r\n   private String gender;\r\n}\r\nThis basic class definition for Person isn't useful at this point, because it defines only Person's attributes (and private ones at that). To be more complete, the Person class needs behavior \u2014 and that means methods.\r\nMethods\r\nA class's methods define its behavior.\r\nMethods fall into two main categories: constructors; and all other methods, which come in many types. A constructor method is used only to create an instance of a class. Other types of methods can be used for virtually any application behavior.\r\nThe class definition back in Listing 1 shows the way to define the structure of a method, which includes elements like:\r\n\u2022\taccessSpecifier\r\n\u2022\treturnType\r\n\u2022\tmethodName\r\n\u2022\targumentList\r\nThe combination of these structural elements in a method's definition is called the method's signature.\r\nNow take a closer look at the two method categories, starting with constructors.\r\nConstructor methods\r\nYou use constructors to specify how to instantiate a class. Listing 1 shows the constructor-declaration syntax in abstract form, and here it is again:\r\naccessSpecifier ClassName([argumentList]) {\r\n  constructorStatement(s)\r\n}\r\nConstructors are optional\r\nIf you don't use a constructor, the compiler provides one for you, called the default (or no-argument or no-arg) constructor. If you use a constructor other than a no-arg constructor, the compiler doesn't automatically generate one for you.\r\nA constructor's accessSpecifier is the same as for variables. The name of the constructor must match the name of the class. So if you call your class Person, the name of the constructor must also be Person.\r\nFor any constructor other than the default constructor (see theConstructors are optional sidebar), you pass an argumentList, which is one or more of:\r\nargumentType argumentName\r\nArguments in an argumentList are separated by commas, and no two arguments can have the same name. argumentType is either a primitive type or another class type (the same as with variable types).\r\nClass definition with a constructor\r\nNow, see what happens when you add the capability to create a Person object in two ways: by using a no-arg constructor and by initializing a partial list of attributes.\r\nListing 3 shows how to create constructors and also how to use argumentList:\r\nListing 3. Person class definition with a constructor\r\npackage com.makotojava.intro;\r\npublic class Person {\r\n  private String name;\r\n  private int age;\r\n  private int height;\r\n  private int  weight;\r\n  private String eyeColor;\r\n \r\n  private String gender;\r\n  public Person() {\r\n    // Nothing to do...\r\n  }\r\n \r\n  public Person(String name, int age, int height, int weight String eyeColor, String gender) {\r\n    this.name = name;\r\n    this.age = age;\r\n    this.height = height;\r\n    this.weight = weight;\r\n    this.eyeColor = eyeColor;\r\n    this.gender = gender;\r\n  }\r\n}\r\nNote the use of the this keyword in making the variable assignments in Listing 3. The this keyword is Java shorthand for \"this object,\" and you must use it when you reference two variables with the same name. In this case, age is both a constructor parameter and a class variable, so the this keyword helps the compiler to tell which is which.\r\nThe Person object is getting more interesting, but it needs more behavior. And for that, you need more methods.\r\nOther methods\r\nA constructor is a particular kind of method with a particular function. Similarly, many other types of methods perform particular functions in Java programs. Exploration of other method types begins in this section and continues throughout the tutorial.\r\nBack in Listing 1, you saw how to declare a method:\r\naccessSpecifier returnType methodName ([argumentList]) {\r\n  methodStatement(s)\r\n}\r\nOther methods look much like constructors, with a couple of exceptions. First, you can name other methods whatever you like (though, of course, certain rules apply). I recommend the following conventions:\r\n\u2022\tStart with a lowercase letter.\r\n\u2022\tAvoid numbers unless they are absolutely necessary.\r\n\u2022\tUse only alphabetic characters.\r\nSecond, unlike constructors, other methods have an optional return type.\r\nPerson's other methods\r\nArmed with this basic information, you can see in Listing 4 what happens when you add a few more methods to the Person object. (I've omitted constructors for brevity.)\r\nListing 4. Person with a few new methods\r\npackage com.makotojava.intro;\r\n \r\npublic class Person {\r\n   private String name;\r\n   private int age;\r\n   private int height;\r\n   private int  weight;\r\n   private String eyeColor;\r\n   private String gender;\r\n \r\n   public String getName() { return name; }\r\n   public void setName(String value) { name = value; }\r\n   // Other getter/setter combinations...\r\n}\r\nNotice the comment in Listing 4 about \"getter/setter combinations.\" You'll work more with getters and setters later. For now, all you need to know is that a getter is a method for retrieving the value of an attribute, and a setter is a method for modifying that value. Listing 4 shows only one getter/setter combination (for the Name attribute), but you can define more in a similar fashion.\r\nNote in Listing 4 that if a method doesn't return a value, you must tell the compiler by specifying the void return type in its signature.\r\nStatic and instance methods\r\nGenerally, two types of (nonconstructor) methods are used: instance methods and static methods. Instance methods depend on the state of a specific object instance for their behavior. Static methods are also sometimes called class methods, because their behavior isn't dependent on any single object's state. A static method's behavior happens at the class level.\r\nStatic methods are used largely for utility; you can think of them as being global methods (\u00E0 la C) while keeping the code for the method with the class that defines it.\r\nFor example, throughout this tutorial, you'll use the JDK Logger class to output information to the console. To create a Logger class instance, you don't instantiate a Logger class; instead, you invoke a static method named getLogger().\r\nThe syntax for invoking a static method on a class is different from the syntax used to invoke a method on an object. You also use the name of the class that contains the static method, as shown in this invocation:\r\nLogger l = Logger.getLogger(\"NewLogger\");\r\nIn this example, Logger is the name of the class, and getLogger(...) is the name of the method. So to invoke a static method, you don't need an object instance, just the name of the class.");
								JScrollPane jsp=new JScrollPane(txtrObjectorientedProgrammingConcepts,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);
								jsp.setBounds(20, 57, 446, 300);
								getContentPane().add(jsp);
								//txtrObjectorientedProgrammingConcepts.setBounds(10, 56, 469, 313);
								//getContentPane().add(txtrObjectorientedProgrammingConcepts);
								JLabel labela = new JLabel(iio);
								labela.setBounds(0, -6, 489,459);
								getContentPane().add(labela);
		
		hp.addActionListener(this);
		cancel.addActionListener(this);
		setSize(505,450);
				
		setLocationRelativeTo(null);
		setVisible(true);
		
		
		
	}

	public static void main(String[] args) 
	{
	new javaz();
	}

	@Override
	public void actionPerformed(ActionEvent e) 
	{
	
Object ob=e.getSource();
		
		if(ob==hp)
		{
			new ProgrammingHub();
			dispose();
		}
		else if(ob==cancel)
		{
			System.exit(0);
		}
	
		
	}
}
